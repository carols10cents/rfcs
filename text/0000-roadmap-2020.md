# Rust 2020 Roadmap RFC Draft

- Feature Name: (fill me in with a unique ident, `my_awesome_feature`)
- Start Date: (fill me in with today's date, YYYY-MM-DD)
- RFC PR: [rust-lang/rfcs#0000](https://github.com/rust-lang/rfcs/pull/0000)
- Rust Issue: [rust-lang/rust#0000](https://github.com/rust-lang/rust/issues/0000)

# Summary
[summary]: #summary

Lays out the Rust roadmap for 2020. The roadmap takes the form of the
following goals for the project:

* Prepare for a possible Rust 2021 Edition
* Follow-up on in-progress designs and efforts
* Improve project functioning, governance, and visibility

# Motivation
[motivation]: #motivation

Every year, the Rust project plans out a roadmap. The process was
kicked off in [RFC 1728], although the shape of roadmaps has changed
from year to year.

[RFC 1728]: https://rust-lang.github.io/rfcs/1728-north-star.html

The goal of the roadmap is to help the Rust teams focus their efforts to ensure
that we are addressing the most prominent problems. This also means providing
areas where the community can help get involved.  The roadmap is based on a
number of sources:

* Preliminary analysis of the [2019 survey], which took place in
  December.
* The [many #rust2020 blog posts][rust2020] written in response to our
  [call for blog posts].
* The thoughts and inputs from the members of the various Rust teams.

[2019 survey]: https://blog.rust-lang.org/2019/12/03/survey-launch.html
[rust2020]: https://readrust.net/rust-2020/
[call for blog posts]: https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html

## Structure of the roadmap

The roadmap this year is based around a few central goals. These goals
are intentionally rather broad -- they are meant to be interpreted
throughout the year by the various teams, as they make decisions about
what to pursue.

We also encourage individual teams to post their thoughts about goals
and ongoing projects for 2020, either in the form of Inside Rust blog
posts or as internals threads.

In addition to the key goals, the roadmap also identifies some themes that we
have identified as common among the feedback received.

# The goals

The list of goals for Rust in 2020 are:

* Prepare for a possible Rust 2021 Edition
* Follow-up on in-progress designs and efforts
* Improve project functioning, governance, and visibility

## Prepare for a Rust 2021 edition

One of our goals for this year should be plan out any changes that we
wish to make as part of the next Rust edition. If we are to continue
the three-year cadence established with the release of Rust 2018, then
the next edition would be released in 2021.

One thing that we learned quite clearly from the experience of Rust
2018 was the importance of preparation. If we wish to do a Rust 2021
edition, we need to be planning for it now. **The goal should be that
any changes we wish to make in Rust 2021 are completed by October of
2020**. Completed here means that the changes are available on
Nightly.

Throughout the survey and feedback from team members, highlights that may
require changes tied to an edition include:

* Error handling, which could potentially see the introduction of new syntactic
  forms;
* Improvements to the trait system, particularly around object safety and
  generic associated types, including a [proposed soundness
  fix](https://github.com/rust-lang/rust/issues/57893#issuecomment-546972824)
  for [#57893];
* Improvements to unsafe code, which might involve introducing new syntax like
  the `&raw` form proposed in [RFC 2582].

[RFC 2582]: https://rust-lang.github.io/rfcs/2582-raw-reference-mir-operator.html
[#57893]: https://github.com/rust-lang/rust/issues/57893

One goal for this year, then, is to flesh out those areas in more detail and
decide what changes, if any, we would like to do for Rust 2021. It is key to
identify and plan out the changes we want to make sufficiently early that the
tooling and documentation around these changes has time to mature before
shipping.

Note that, as ever, any edition-related change would require appropriate tooling
to help people transition their code. Furthermore, the compiler would continue
to support older editions, ensuring that Rust's stability promise is maintained.

When the October 2020 deadline arrives, we may find that we have no changes
planned that require an edition. We expect that by the end of October, we will
have an RFC up (and ideally merged) indicating whether a 2021 edition will
occur, as well as laying the groundwork for its theme.

## Follow-up on in-progress designs and efforts

A major theme highlighted in numerous blog posts and team member's feedback is
our current long queues, and indeed tendency for "unbounded queues." This often
leads to RFCs which are accepted and have remained unimplemented for years,
making it unclear what their current state is. Often, the rationale laid out by
the RFC is either no longer true, or at least lacks modern context.

Over the past several years, we have experimented with several concepts: working
groups as part of the 2018 edition (specifically, domain working groups) and
project groups (inline assembly, safe transmute). The language team has also
explored the use of shepherds to guide RFCs. The compiler team has a wide area
of subgroups targeting a specific initiative (such as self-profile, or rls-2.0).

It is unclear to many which of these efforts is still ongoing and which naming
conventions to use; one of the goals for 2020 is to clarify the scope of these
groups and lay the groundwork for future iteration. We should reflect on the
success and failures of past attempts, and work to ensure that going forward we
use the more successful strategies.

We also intend to set a high level goal of flushing our queues. We should work
to reduce the backlog of accepted RFCs and in progress ideas, whether by
explicitly rejecting or implementing them. This does not mean that we should not
accept new work -- but we should have a high level goal in mind of finishing the
year with less, rather than more, "planned" work.

## Improve project functioning, governance, and visibility

In concert with the previous goal of working on flushing specific ideas, we also
have identified that Rust governance as a whole is likely in need of some
restructuring. Rust has grown increasingly large, and we need to implement
strategies such as working groups and project groups to prevent overloading
our teams with work.

We believe that a key area where we currently are lacking in visibilty is
tracking the state of any given "big idea." We should aim to surface these in a
way that is first visible internally to the teams, and second visible to the
broader community.

This is also true of individual team members, where it can frequently be unclear
who in a team has spare capacity and can be approached for feedback on
brainstorms or when pursuing some major change.

# Drawbacks
[drawbacks]: #drawbacks

One concern that has come up this year in particular is that we frequently do
not "tie" efforts actively to goals established in past roadmaps. This is one
reason that this year's roadmap is specifically intended to be much more high
level, with the fine grained details left up to the individual teams and the
community to decide upon.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

- Why is this design the best in the space of possible designs?
- What other designs have been considered and what is the rationale for not choosing them?
- What is the impact of not doing this?

# Prior art
[prior-art]: #prior-art

Discuss prior art, both the good and the bad, in relation to this proposal.
A few examples of what this can include are:

- For language, library, cargo, tools, and compiler proposals: Does this feature exist in other programming languages and what experience have their community had?
- For community proposals: Is this done by some other community and what were their experiences with it?
- For other teams: What lessons can we learn from what other communities have done here?
- Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.

This section is intended to encourage you as an author to think about the lessons from other languages, provide readers of your RFC with a fuller picture.
If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other languages.

Note that while precedent set by other languages is some motivation, it does not on its own motivate an RFC.
Please also take into consideration that rust sometimes intentionally diverges from common language features.

# Unresolved questions
[unresolved-questions]: #unresolved-questions

- What parts of the design do you expect to resolve through the RFC process before this gets merged?
- What parts of the design do you expect to resolve through the implementation of this feature before stabilization?
- What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?

# Future possibilities
[future-possibilities]: #future-possibilities

Think about what the natural extension and evolution of your proposal would
be and how it would affect the language and project as a whole in a holistic
way. Try to use this section as a tool to more fully consider all possible
interactions with the project and language in your proposal.
Also consider how the this all fits into the roadmap for the project
and of the relevant sub-team.

This is also a good place to "dump ideas", if they are out of scope for the
RFC you are writing but otherwise related.

If you have tried and cannot think of any future possibilities,
you may simply state that you cannot think of anything.

Note that having something written down in the future-possibilities section
is not a reason to accept the current or a future RFC; such notes should be
in the section on motivation or rationale in this or subsequent RFCs.
The section merely provides additional information.
